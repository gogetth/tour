ชนิดของตัวแปรที่มากขึ้น: structs, slices, และ maps
เรียนรู้การประการชนิดของตัวแปรที่อ้างถึงตัวแปรที่มีอยู่แล้ว: ในบทเรียนนี้จะครอบคลุมถึง structs, arrays, slices, และ maps

The Go Authors
https://golang.org

* Pointers

ภาษาโกมีพอยเตอร์
พอยเตอร์หรือตัวชี้ จะเก็บที่อยู่ในหน่วยความจำของค่าใดก็ตามไว้

ชนิดของตัวแปร `*T` ก็คือพอยเตอร์ที่ชี้ไปที่ค่าของ `T` และค่าว่างของมันคือ `nil`

	var p *int

เครื่องหมาย `&` จะมอบพอยเตอร์ของค่าที่มันอยู่ด้วย ให้กับอะไรก็ตามที่จะมารับค่านั้นไป

	i := 42
	p = &i

เครื่องหมาย `*` คือการชี้ลงไปที่ค่าที่อยู่ภายใต้พอยเตอร์นั้น

	fmt.Println(*p) // อ่านค่า i ที่อยู่ในพอยเตอร์ p
	*p = 21         // กำหนดค่าให้ i ที่อยู่ในพอยเตอร์ p


สิ่งนี้รู้จักกันในชื่อ "dereferencing" หรือ "indirecting"
_คือการนำเอาค่าออกมาจากพอยเตอร์_

และที่ต่างจากภาษาซีคือ ในภาษาโก ไม่สามารถเอาค่าพอยเตอร์มาคำนวณได้

.play moretypes/pointers.go

* Structs

`struct` คือที่รวมของฟิลด์หรือตัวแปร

.play moretypes/structs.go

* ข้อมูลใน Struct

การเข้าถึงฟิลด์ใน struct คือการใช้เครื่องหมายจุด

.play moretypes/struct-fields.go

* พอยเตอร์ของ struct

ฟิลด์ต่าง ๆ ในพอยเตอร์ของ struct ก็ยังสามารถอ้างถึงได้เหมือนเดิม

การอ้างถึง `X` ที่อยู่ใน struct ในกรณีที่ `p` เป็นพอยเตอร์ของ struct
ก็น่าจะต้องเขียนว่า `(*p).X`
แต่ถ้าทำแบบนั้นมันก็จะดูยุ่งยาก ตัวภาษาจึงอนุญาตให้เราเขียนแบบนี้ `p.X` แทน

.play moretypes/struct-pointers.go

* วิธีประกาศตัวแปรของ struct

การประกาศตัวแปรของ struct คือการจองหน่วยความจำเพื่อเก็บค่าแต่ละฟิลด์ที่ระบุลงไป

คุณสามารถระบุแค่บางชื่อก็ได้ (และลำดับของฟิลด์ก็ไม่มีนัยยะ)

เครื่องหมาย `&` จะคืนพอยเตอร์ที่ชี้ไปที่ค่าของ struct นั้น

.play moretypes/struct-literals.go


* Arrays

ชนิดของตัวแปรแบบ `[n]T` คืออาร์เรย์ ที่มีขนาด `n` ของชนิดตัวแปร `T`

การประกาศแบบนี้

	var a [10]int

คือการประกาศตัวแปร `a` เป็น อาร์เรย์ของ integer ขนาดสิบตัว

ความยาวของอาร์เรย์เป็นส่วนหนึ่งของชนิดตัวแปร และอาร์เรย์ไม่สามารถเปลี่ยนขนาดได้
ดูเหมือนจะมีข้อจำกัด แต่อย่ากังวล
ภาษาโกได้เตรียมอำนวยความสะดวกในการทำงานกับอาร์เรย์ไว้ให้แล้ว

.play moretypes/array.go


* Slices

ในเมื่ออาร์เรย์นั้นต้องมีขนาดคงที่
ในทางกลับกัน slice ก็จะมีขนาดแปรผันได้
เป็นเหมือนอาร์เรย์แบบยืดหยุ่น
ในทางปฏิบัติ slice ถูกใช้บ่อยกว่าอาร์เรย์

ชนิดของตัวแปร `[]T` คือ slice ของตัวแปรชนิด `T`

วิธีนี้จะสร้าง slice จากสมาชิกตัวแรกไปจนถึงตัวที่ห้าจากอาร์เรย์ `a`

	a[0:5]


.play moretypes/slices.go


* Slices ก็คือการอ้างถึงอาร์เรย์

slice เองจะไม่เก็บข้อมูลอะไรเลย
มันแค่เป็นตัวอธิบายขอบเขตของสมาชิกในอาร์เรย์

การแก้ไขสมาชิกใน slice ก็คือการแก้ไข
ไปที่สมาชิกของอาร์เรย์ที่มันอ้างถึงนั่นเอง

และ slice ตัวอื่นที่ใช้อาร์เรย์เดียวกันก็จะเห็นการเปลี่ยนแปลงนั้นด้วย

.play moretypes/slices-pointers.go


* วิธีการประกาศตัวแปร slice

การประกาศตัวแปรของ slice นั้นคล้ายกับรูปแบบของอาร์เรย์ เพียงแค่ไม่มีขนาดกำกับ

นี่คือการประกาศตัวแปรอาร์เรย์:

	[3]bool{true, true, false}

และนี่คือการสร้างอาร์เรย์แบบเดียวกับด้านบน
แล้วก็สร้าง slice ที่อ้างถึงอาร์เรย์นั้นไปพร้อมกัน

	[]bool{true, true, false}

.play moretypes/slice-literals.go


* Slice defaults

เวลาที่คุณจะตัด slice คุณสามารถที่จะไม่ระบุขอบบน หรือขอบล่างได้ ซึ่งมันจะเข้าใจได้

ว่าถ้าเป็นขอบล่างจะหมายถึงค่าศูนย์ ส่วนขอบบนจะหมายถึงขอบจำนวนสูงที่สุดของมัน

ถ้ามีอาร์เรย์แบบนี้

	var a [10]int

slice พวกนี้จะหมายถึงค่าเดียวกันเลย:

	a[0:10]
	a[:10]
	a[0:]
	a[:]

.play moretypes/slice-bounds.go


* ความยาวและความจุของ slice

slice มีทั้ง _ความยาว_ และ _ความจุ_

ความยาวคือจำนวนของสิ่งที่บรรจุอยู่ภายใน slice

ความจุ คือขนาดของอาร์เรย์ที่อยู่ภายใน slice โดยเริ่มนับจากตัวแรกที่ slice ชี้อยู่

ความยาวและความจุของ slice ที่ชื่อ `s` สามารถรู้ได้จากการใช้คำสั่ง
`len(s)` และ `cap(s)`

คุณสามารถขยายความยาวของ slice ได้ด้วยการหั่นมันซ้ำอีกครั้ง
ให้ได้ขนาดที่จำเป็นต้องใช้
ทดลองแก้ไขค่าในตัวอย่างดูสักค่าหนึ่ง ลองขยายมันออกไปให้เกินความจุ
แล้วดูว่าจะเกิดอะไรขึ้น

.play moretypes/slice-len-cap.go


* ค่าว่างของ slice

ค่าว่างของ slice คือ `nil`

slice ที่เป็น nil จะมีความยาวและความจุเป็น 0
และไม่มีอาร์เรย์อยู่ในนั้น

.play moretypes/nil-slices.go


* สร้าง slice ด้วยคำสั่ง make

คุณสามารถสร้าง slice ได้ด้วยฟังก์ชั่นที่มีภายในภาษาโกที่ชื่อ `make`
นี่คือวิธีที่คุณสามารถสร้าง อาร์เรย์ที่มีขนาดแปรผันได้

ฟังก์ชั่น `make` จะจองอาร์เรย์ขนาดศูนย์และส่ง slice
ที่อ้างถึงอาร์เรย์นั้นออกไป

	a := make([]int, 5)  // len(a)=5

ถ้าต้องการระบุความจุให้มันก็ทำได้ด้วยการใส่ค่าอาร์กิวเม้นต์ที่สามให้ `make`

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go


* Slices ของ slices

ภายใน slice สามารถมีตัวแปรชนิดไหนอยู่ก็ได้ ไม่เว้นแม้แต่ slice ด้วยกันเอง

.play moretypes/slices-of-slice.go


* การต่อท้าย slice

มันเป็นเรื่องธรรมดาของการเอาข้อมูลไปต่อท้าย slice และภาษาโกก็มีฟังก์ชั่นภายในมาให้ใช้
ชื่อว่า `append` ดูเอกสารได้ที่ [[https://golang.org/pkg/builtin/#append][เอกสาร]]
ซึ่งจะอธิบายทุกอย่างของฟังก์ชั่นภายใน ในส่วนของ `append`

	func append(s []T, vs ...T) []T

พารามิเตอร์ตัวแรกคือ `s` ใน `append` คือตัวแปร slice ที่มีชนิดข้อมูล `T` ส่วนที่เหลือ
คือข้อมูลที่มีชนิด `T` ที่ต้องการนำไปต่อท้าย slice

ผลลัพธ์ที่ได้จาก `append` ก็คือ slice ตัวใหม่ที่มีข้อมูลทั้งหมดของ slice ตัวเก่า
บวกกับ ค่าที่นำไปต่อท้ายทั้งหมด

ถ้าอาร์เรย์ที่อยู่ใน slice `s` มีขนาดเล็กกว่าข้อมูลที่จะเก็บทั้งหมด มันจะจัดสรรขนาดใหม่
slice ที่คืนออกไปจะชี้ไปที่อาร์เรย์ที่มีขนาดใหม่แทน

(ถ้าต้องการเรียนรู้เพิ่มเติมเกี่ยวกับ slice อ่านต่อได้ที่ [[https://blog.golang.org/go-slices-usage-and-internals][Slices: วิธีใช้]])

.play moretypes/append.go


* Range

คำเฉพาะ `range` ใช้กับ `for` เพื่อวนลูปของใน slice หรือ map

เมื่อเราเริ่มใช้ range กับ slice จะได้ค่ากลับมาสองค่าไปเรื่อย ๆ ทุก ๆ รอบของลูป
ค่าแรกคือ ดัชนี หรือตำแหน่งของข้อมูลใน slice และค่าที่สองก็คือข้อมูลที่สำเนามาจากข้อมูลในตำแหน่งนั้น

.play moretypes/range.go

* Range (ต่อ)

คุณสามารถละเว้นการรับค่า ดัชนี หรือ ข้อมูล ด้วยการใช้สัญลักษณ์ `_`

ถ้าคุณต้องการแค่ค่าดัชนี ก็เอาส่วนของ ", value" ออกไปได้เลย

.play moretypes/range-continued.go

* แบบฝึกหัด: Slices

ให้เขียนการทำงานของ `Pic` โดยมันควรที่จะคืนค่า slice ที่มีความยาวเท่ากับ `dy` และในแต่ละชิ้นของ slice นั้น ก็คือ slice ของ `dx` ที่มีชนิดข้อมูลเป็น integer พอคุณรันโปรแกรม มันจะแสดงภาพของคุณ โดยมันจะแปลข้อมูลพวกตัวเลขไปเป็นโทนสีของภาพขาวดำ (หรือดีกว่านั้นก็เป็นโทนสีฟ้า)

จะเลือกภาพอะไรก็ได้แล้วแต่คุณเลย ฟังก์ชั่นที่น่าสนใจจะมี `(x+y)/2`, `x*y`, and `x^y` ร่วมอยู่ด้วย

(คุณต้องใช้การวนลูปเพื่อที่จะกำหนดค่า `[]uint8` ไว้ใน `[][]uint8`)

(และใช้ `uint8(intValue)` เพื่อแปลงชนิดข้อมูล)

.play moretypes/exercise-slices.go

* Maps

map ใช้จับคู่ด้วยคีย์กับข้อมูลเข้าด้วยกัน

ค่าว่างของ map คือ `nil`
`nil` ของ map ก็คือ ไม่มีคีย์เลย และก็ใส่ลงไปไม่ได้ด้วย

ฟังก์ชั่น `make` จะคืนค่า map พร้อมชนิดข้อมูลกลับมา และทำให้พร้อมใช้งานด้วย

.play moretypes/maps.go

* การประกาศตัวแปร Map

การประกาศตัวแปรแบบ map นั้นคล้ายกับ struct แต่ต่างกันตรงที่ map จะต้องมีคีย์เสมอ

.play moretypes/map-literals.go

* การประกาศตัวแปร Map (ต่อ)

ชั้นบนสุดของการประกาศคือชนิดของข้อมูล คุณไม่จำเป็นต้องใส่ชนิดของข้อมูลให้ข้อมูลทีละชุดก็ได้

.play moretypes/map-literals-continued.go

* วิธีใช้ Maps

เพิ่มข้อมูลหรือแก้ไขข้อมูลใน map `m` แบบนี้:

	m[key] = elem

การเอาข้อมูลออกมาทำแบบนี้:

	elem = m[key]

การลบข้อมูลออกทำแบบนี้:

	delete(m, key)

วิธีทดสอบว่ามีกุญแจนั้นอยู่หรือไม่ ด้วยการคืนสองค่าแบบนี้ออกมา:

	elem, ok = m[key]

ถ้า `key` มีอยู่ใน `m` จริง ค่า `ok` จะเป็น `true` แต่ถ้าไม่มี `ok` จะเป็น `false`

ถ้า `key` ไม่มีอยู่ใน map ค่า `elem` จะเป็นค่าว่างของชนิดข้อมูลนั้น

_ข้อควรจำ_: ถ้า `elem` หรือ `ok` ยังไม่ได้ถูกประกาศไว้ก่อน คุณควรใช้การประกาศตัวแปรแบบย่อ:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* แบบฝึกหัด: Maps

จงเขียน `WorkCount` ให้เสร็จ โดยมันควรคืนค่า map ที่นับจำนวนคำแต่ละคำที่อยู่ในข้อความของตัวแปร `s` ฟังก์ชั่น `wc.Test` เป็นระบบทดสอบความถูกต้องให้ฟัง์ชั่นของคุณ โดยมันจะแสดงข้อความ สำเร็จ หรือ ล้มเหลว ออกมาให้

ข้อมูลในนี้ [[https://golang.org/pkg/strings/#Fields][strings.Fields]] อาจช่วยคุณได้บ้าง

.play moretypes/exercise-maps.go

* ฟังก์ชั่นใช้เหมือนตัวแปร

ฟังก์ชั่น สามารถเป็นข้อมูลได้ด้วย มันสามารถนำไปใช้เหมือนเป็นตัวแปรได้เลย

ฟังก์ชั่นที่เป็นข้อมูลได้นี้ อาจจะถูกน้ำไปใช้เป็นอาร์กิวเม้นต์ให้ฟังก์ชั่นอื่น หรือใช้เป็นค่าส่งคืนออกมาก็ได้

.play moretypes/function-values.go

* การสร้างอาณาเขตของฟังก์ชั่น

ฟังก์ชั่นในภาษาโกสามารถสร้างอาณาเขตในการการอ้างถึงตัวแปรได้ในบางวิธี

การสร้างอาณาเขต คือฟังก์ชั่นที่มีสภาวะเป็นตัวแปร จะสามารถอ้างถึงตัวแปรที่อยู่นอกตัวเองได้

ซึ่งอาจจะอ้างถึงหรือกำหนดค่าได้ด้วย ประหนึ่งว่าเป็นตัวแปร "ภายใน" ของตัวมันเอง

จากตัวอย่างนี้ ฟังก์ชั่น `adder` จะคืนค่าเป็นฟังก์ชั่นแบบสร้างอาณาเขต โดยแต่ละฟัง์ชั่นที่ได้มานั้น จะมีอาณาเขตครอบคลุมถึงตัวแปร `sum` ของตัวเอง

.play moretypes/function-closures.go

* แบบฝึกหัด: Fibonacci closure

ขอให้สนุกกับฟังก์ชั่น

ให้ทำฟังก์ชั่น `fibonacci` ให้เสร็จ โดยมันจะคืนฟังก์ชั่น (สร้างอาณาเขต)
ที่จะคืนค่า[[https://en.wikipedia.org/wiki/Fibonacci_number][ตัวเลข ฟีโบนัคซี่]] ออกมาอย่างต่อเนื่อง
(0, 1, 1, 2, 3, 5, ...)

.play moretypes/exercise-fibonacci-closure.go

* ยินดีด้วย!

คุณจบบทนี้แล้ว!

คุณสามารถย้อนกลับไปดูรายการทั้งหมดได้ที่ [[/list][modules]] เพื่อค้นหาสิ่งที่คุณอยากจะเรียนรู้ต่อ หรือไปสู่ [[javascript:click('.next-page')][บทถัดไป]]
