เมธอดและอินเตอร์เฟส
บทเรียนนี้จะครอบคลุมเมธอดและอินเตอร์เฟส รวมถึงวิธีการประกาศออบเจ็กต์และพฤติกรรมของออบเจ็กต์นั้น

The Go Authors
https://golang.org

* Methods

ภาษาโกไม่มีการสร้างคลาส
แต่อย่ากังวล เพราะคุณยังสามารถสร้าง เมธอดให้ชนิดตัวแปรได้

เมธอดก็คือฟังก์ชั่น ที่มี _ตัวรับ_ ซึ่งเป็นอาร์กิวเม้นต์แบบพิเศษ

เจ้าตัวรับนี้จะปรากฎอยู่ระหว่างคำเฉพะา `func` และชื่อเมธอด

จากตัวอย่างนี้ เมธอด `Abs` มีตัวรับเป็น ชนิดของตัวแปร `Vertex` เข้ามาด้วยชื่อ `v`

.play methods/methods.go

* เมธอด คือ ฟังก์ชั่น

ข้อควรจำ: เมธอด แท้จริงแล้วก็คือฟังก์ชั่นธรรมดาเพียงแค่มี อาร์กิวเม้นต์ที่เรียกว่าตัวรับ

และนี่คือการเขียน `Abs` ในแบบฟังก์ชั่นธรรมดาโดยไม่มีการปรับเปลี่ยนกระบวนการทำงานเลย

.play methods/methods-funcs.go

* เมธอด (ต่อ)

คุณสามารถสร้าง เมธอด ไว้กับชนิดตัวแปรที่ไม่ได้เป็นแบบ struct ได้ด้วย

ในตัวอย่างนี้ เราจะชนิดของตัวแปรที่ชื่อ `MyFloat` ที่เป็นชนิดตัวแปรแบบตัวเลข มีเมธอด `Abs`

คุณสามารถสร้างเมธอดให้กับตัวรับอะไรก็ได้ที่อยู่ในแพ็กเกจเดียวกันเท่านั้น
และคุณจะไม่สามารถสร้างเมธอดให้กับตัวรับใด ๆ ก็ตามที่ถูกสร้างไว้ที่แพ็กเกจอื่น (รวมถึงชนิดตัวแปรที่มาพร้อมตัวภาษาเช่น `int`)

.play methods/methods-continued.go

* ตัวรับแบบพอยเตอร์

คุณสามารถสร้างเมธอดที่มีตัวรับแบบพอยเตอร์ได้

หมายความว่าตัวรับสามารถประกาศแบบนี้ `*T` สำหรับชนิดตัวแปรแบบ `T`
(เว้นแต่ว่าตัวแปร `T` จะมีพอยเตอร์ไม่ได้ ยกตัวอย่างเช่น `*int`)

จากตัวอย่าง เมธอด `Scale` ถุกสร้างไว้บน `*Vertex`

เมธอดบนตัวรับแบบพอยเตอร์จะสามารถแก้ไขค่าต่าง ๆ ที่พอยเตอร์เก็บไว้ได้ (เหมือนที่ `Scale` ทำอยู่นี้)
และเนื่องจากเมธอดส่วนมากมักจะต้องแก้ไขค่าในตัวรับ การใช้พอยเตอร์เป็นตัวรับมักจะถูกใช้บ่อยมากกว่าการไม่ใช้

ทดลองลบ `*` ออกจากการประกาศฟังก์ชั่น `Scale` ที่บรรทัดที่ 16 แล้วพิจารณาดูว่า
พฤติกรรมของโปรแกรมจะเปลี่ยนไปอย่างไร

ส่วนการใช้ตัวรับแบบตัวแปรธรรมดา เมธอด `Scale` จะสำเนาค่าต่าง ๆ จาก `Vertex` มาเก็บไว้
(ซึ่งจะไม่ต่างอะไรกับที่ฟังก์ชั่นทั่วไปรับอาร์กิวเม้นต์เข้ามา)

เมธอด `Scale` จึงจำเป็นต้องใช้ ตัวรับพอยเตอร์ เพื่อจะได้เปลี่ยนค่าใน `Vertext` ที่ประกาศในฟังก์ชั่น `main` ได้

.play methods/methods-pointers.go

* พอยเตอร์ และ ฟังก์ชั่น

ตอนนี้เรามาดูเมธอด `Abs` และ `Scale` ที่ถูกเขียนใหม่ในแบบฟังก์ชั่น

เรามาลองลบ `*` ออกจากบรรทัดที่ 16 ดูอีกที
ว่าคุณจะเห็นพฤติกรรมมันเปลี่ยไปไหม?
มีอะไรที่คุณอยากจะแก้ไขก่อนที่จะคอมไฟพ์ตัวอย่างนี้บ้างหรือเปล่า

(ถ้าคุณไม่แน่ใจ ให้ไปหน้าถัดไปเลย)

.play methods/methods-pointers-explained.go

* Methods and pointer indirection

เมื่อเปรียบเทียบกับโปรแกรมสองตัวก่อนหน้านี้ คุณจะสังเกตได้ว่า
ฟังก์ชั่นที่ต้องการอาร์กิวเม้นต์แบบพอยเตอร์ จะต้องให้ค่าพอย์เตอร์กับมัน

	var v Vertex
	ScaleFunc(v)  // Compile error!
	ScaleFunc(&v) // OK

ในขณะที่เมธอดที่มีตัวรับเป็นพอยเตอร์นั้น เจ้าตัวรับเอง จะมีค่าเป็นพอยเตอร์หรือแค่ค่าธรรมดาก็ได้
เวลาที่มันเรียกเมธอด:

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

จากบรรทัดที่ `v.Scale(5)` แม้ว่า `v` จะเป็นค่าธรรมดา ไม่ใช่พอยเตอร์
มันจะเรียกใช้เมธอดที่มีตัวรับเป็นพอยเตอร์ให้เองได้อัตโนมัติ
นี่คือสิ่งที่ภาษาโกหอำนวยความสะดวกให้ โดยมันจะแปลบรรทัด `v.Scale(5)` นี้
ไปเป็น `(&v).Scale(5)` แบบนี้ให้ ถ้าหากว่า `Scale` เป็นเมธอดที่มีตัวรับเป็นพอยเตอร์

.play methods/indirection.go

* Methods and pointer indirection (2)

ในทางกลับกัน ก็จะทำแบบเดียวกัน

ฟังก์ชั่นที่ต้องการอาร์กิวเม้นแบบค่าปกติ ก็จะต้องให้ค่าที่เป็นชนิดตัวแปรปกติ:

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Compile error!

ในขณะที่เมธอดที่มีตัวรับเป็นตัวแปรปกติ จะมีค่าเป็นค่าปกติหรือจะเป็นพอยเตอร์ก็ได้:

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

ในกรณีนี้ ตอนที่เรียก `p.Abs()` มันจะถูกแปรไปเป็น `(*p).Abs()`

.play methods/indirection-values.go

* จะเลือกตัวรับเป็นแบบค่าปกติหรือแบบพอยเตอร์ดี

มีสองเหตุผลที่ควรจะใช้ตัวรับแบบพอยเตอร์

อย่างแรกคือ เมธอดนั้นมีความสามารถที่จะแก้ไขค่าที่ตัวรับชี้อยู่

อย่างที่สอง คือไม่อยากสำเนาค่าของตัวรับไปใส่ในทุกเมธอด
ซึ่งนี้จะส่งผลทางด้านประสิทธิภาพการทำงานถ้าหากว่าตัวรับมีโครงสร้างขนาดใหญ่ ดูตัวอย่าง

ในตัวอย่างนี้ ทั้สองเมธอด `Scale` และ `Abs` มีตัวรับเป็น `*Vertex` ทั้งคู่
แต่ว่าเมธอด `Abs` ไม่ได้มีความต้องการที่จะแก้ไขค่าที่ตัวรับเลย

โดยปกติแล้ว ทุกเมธอดจะเลือกการใช้ตัวรับวิธีเดียว ไม่ว่าจะแบบตัวแปรปกติหรือพอยเตอร์
แต่จะไม่มีทั้งสองแบบในเวลาเดียวกัน
(เราจะได้เห็นว่าเพราะอะไรในอีกไม่กี่หน้าต่อไปนี้)

.play methods/methods-with-pointer-receivers.go

* Interfaces

ตัวแปร _ชนิด_interface_ ถูกใช้สำหรับออกแบบโครงสร้างเมธอด

ค่าอะไรก็ตามที่จะถูกเก็บในตัวแปร interface นี้จะต้องมีเมธอดที่ออกแบบไว้อยู่ด้วย

*ข้อควรจำ:* ความผิดพลาดในตัวอย่างบรรทัดที่ 22 เกิดจาก
`Vertex` (ตัวแปรแบบปกติ) ไม่ได้สร้างตามแบบที่ `Abser` วางไว้
เพราะว่า เมธอด `Abs` ถูกสร้างไว้กับตัวรับ `*Vertex` (ที่เป็นพอยเตอร์)

.play methods/interfaces.go

* Interfaces are implemented implicitly

ชนิดตัวแปรจะเป็นไปตาม interface โดยปริยายด้วยการสร้างเมธอดให้ตรงกัน
โดยไม่ต้องมีการประกาศอย่างจงใจ ไม่มีคำเฉพาะ `implements` ใด ๆ

การเป็นเองโดยปริยายนี้ ทำให้การออกแบบ interface แบบการสร้างของตามแบบนั้น
ไม่ยึดติดกัน ซึ่งจะทำให้สามารถสร้างของแบบนี้ที่ไหนก็ได้โดยไม่ต้องแจ้งล่วงหน้า

.play methods/interfaces-are-satisfied-implicitly.go

* Interface values

ข้อมูลที่อยู่ภายใต้ interface ให้คิดง่าย ๆ ว่าคือ ค่า และ ชนิดของตัวแปร:

	(value, type)

interface จะเก็บ ค่า ของชนิดของตัวแปรที่แท้จริงของมัน

การเรียกเมธอดบน interface คือการเรียกเมธอดชื่อที่ตรงกันของค่าที่อยู่ใต้ interface นั้น


.play methods/interface-values.go

* ค่า nil ภายใต้ interface

ถ้าค่าข้างใน interface เป็น nil
เมธอดจะถูกเรียกไปที่ตัวรับที่เป็น nil

ในบางภาษาโปรแกรมมิ่ง นี้อาจจะทำให้เกิด null pointer exception
แต่ในภาษาโก เรามีวิธีที่จะจัดการการเรียกเมธอดผ่านมาทางตัวรับที่เป็น nil
ได้อย่างงดงาม (เหมือนที่เมธอด `M` ทำในตัวอย่าง)

โปรดจำไว้ว่าตัวแปรของ interface ที่มีค่าด้านล่างเป็น nil ความจริงตัวมันไม่ได้เป็น nil ไปด้วย

.play methods/interface-values-with-nil.go

* Nil interface values

interface ที่เป็น nil จะไม่ถือ ค่าใด ๆ หรือแม้แต่ชนิดตัวแปรอะไรไว้เลย

การเรียกเมธอดบน interface ที่เป็น nil จะส่งผลให้เกิดความผิดพลาดแบบ run-time เพราะว่า
มันไม่มีชนิดตัวแปรอะไรข้างในเลย ที่จะสามารถอ้างถึง _เมธอดจริง_ๆ_ เพื่อเอามาใช้งานได้

.play methods/nil-interface-values.go

* interface ที่ว่างเปล่า

ชนิดตัวแปร interface สามารถที่จะไม่มีเมธอดเลยได้ เราเรียกมันว่า _empty_interface_:

	interface{}

interface ว่าง นี้สามารถจะเก็บค่าของตัวแปรชนิดไหนก็ได้
(ทุกชนิดของตัวแปรที่มีอย่างน้อย ศูนย์เมธอด)

interface ว่าง จะถูกใช้ในโค้ดที่ต้องการจะใช้ตัวแปรที่ไม่รู้ชนิดของตัวแปร
ตัวอย่างเช่น `fmt.Print` จะรับอาร์กิวเม้นต์อะไรก็ได้กี่ตัวก็ได้ที่มีชนิดตัวแปรเป็น `interface{}`

.play methods/empty-interface.go

* การยืนยันชนิดของตัวแปร

_การยืนยันชนิดของตัวแปร_ คือการอำนวยความสะดวกให้เข้าถึงค่าจริง ๆ ที่อยู่ภายใต้ interface

	t := i.(T)

บรรทัดนี้คือการระบุว่าจะเข้าถึงค่าข้างใน interface ด้วยชนิดตัวแปร `T` โดยตรง
และนำเอาค่าด้านในนั้นที่มีชนิดตัวแปร `T` ออกมาเก็บไว้ที่ตัวแปร `t`

แต่ถ้า `i` ไม่ได้ถือตัวแปรชนิด `T` เอาไว้จริง ๆ บรรทัดนี้จะทำให้เกิด panic

เราจึงสามารถ _ทดสอบ_ ก่อนได้ว่า interface นั้นได้ถือค่าที่มีชนิดตัวแปรที่ว่าอยู่จริงหรือไม่
การยืนยันชนิดตัวแปรสามารถคืนค่าออกมาได้สองค่า คือค่าตามที่ระบุชนิดตัวแปรไป
และค่านิพจน์ที่จะรายงานว่าการยืนยันชนิดตัวแปรนั้นสำเร็จ

	t, ok := i.(T)

ถ้า `i` ถือค่าของชนิด `T` อยู่จริง `t` จะได้ค่าตามชนิดนั้นออกมา และ `ok` จะเป็นจริง

แต่ถ้าไม่ `ok` จะเป็นเท็จ และ `t` จะเป็นค่าว่างตามชนิดตัวแปร `T`
และไม่ทำให้เกิด panic

ข้อสังเกต นี่จะคล้ายกับรูปแบบของการอ่านค่าจากตัวแปรแบบ map

.play methods/type-assertions.go

* Type switches

_type_switch_ คือโครงสร้างที่อนุญาตให้ยืนยันชนิดตัวแปรได้เป็นชุด ๆ

การใช้งานก็คล้ายกับการใช้ switch ธรรมดา เพียงแต่ในเงื่อนไขแต่ละ case
คือชนิดของตัวแปรโดยตรง (ไม่ใช่ค่า) ซึ่งจะถูกนำมาเปรียบเทียบกับชนิดตัวแปร
ที่ interface ถืออยู่

	switch v := i.(type) {
	case T:
		// จะทำตรงนี้ถ้า v เป็นตัวแปรชนิด T
	case S:
		// จะทำตรงนี้ถ้า v เป็นตัวแปรชนิด S
	default:
		// ไม่ตรงเลย; จะทำตรงนี้ถ้า v เป็นตัวแปรชนิดเดียวกับ i
	}

การประกาศชนิดตัวแปรสำหรับใช้ใน switch ก็เหมือนกับการยืนยันชนิดตัวแปร `i.(T)`
แต่แทนที่จะระบุชนิดไปเลยว่า `T` ก็แทนที่ด้วยคำเฉพาะ `type`

switch นี้ จะทดสอบว่า interface `i` ถือค่า
ของตัวแปรชนิดไหนอยู่ `T` หรือว่า `S`
ในกรณีไม่ว่าจะเป็น `T` หรือ `S` ตัวแปร `v` มีชนิดตัวแปรตาม
`T` หรือ `S` และถือค่าตามที่ `i` ถืออยู่ด้วย
ในกรณีที่ไปตก default (ถ้าไม่ตรงกับชนิดไหนเลย) ตัวแปร `v`
จะมีชนิดตัวแปรตามจริงที่ `i` เก็บไว้

.play methods/type-switches.go

* Stringers

interface ตัวหนึ่งที่ถูกใช้อย่างมากเลย คือ [[//golang.org/pkg/fmt/#Stringer][`Stringer`]] ที่อยู่ในแพ็กเกจ [[//golang.org/pkg/fmt/][`fmt`]]

	type Stringer interface {
		String() string
	}

`Stringer` เป็นชนิดตัวแปรที่สามารถอธิบายตัวเองออกมาเป็นข้อความ โดยแพ็กเกจ `fmt`
(และอีกหลาย ๆ แพ็กเกจ) จะมองหา interface นี้เพื่อพิมพ์ค่าออกมา

.play methods/stringer.go

* แบบฝึกหัด: Stringers

จงทำให้ `IPAddr` มีคุณลักษณะตาม `fmt.Stringer` เพื่อจะแสดง ip address คั่นด้วย จุด

ตัวอย่างเช่น `IPAddr{1,`2,`3,`4}` ควรพิมพ์ออกมาเป็น `"1.2.3.4"` 

.play methods/exercise-stringer.go

* Errors

ภาษาโก ใช้ค่า `error` เมื่อเกิดข้อผิดพลาดอย่างตรงไปตรงมา

ตัวแปรชนิด `error` นี้เป็น interface ที่มาพร้อมตัวภาษาแบบ built-in และมีหน้าตาดูคล้ายกับ `fmt.Stringer`:

	type error interface {
		Error() string
	}

(และ `fmt` จะพยายามมองหา interface `error ` เหมือนกับที่หา `fmt.Stringer` เมื่อต้องการพิมพ์ค่าใดก็ตาม)

โดยปกติแล้ว ฟังก์ชั่น มักจะคืนค่า `error` ออกมาเสมอ และตอนที่เรียกใช้ก็ควรจัดการรีบมือ error เหล่านี้
โดยทดสอบว่า error มีค่าเป็น `nil` หรือไม่ เช่น

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

ถ้า `error` เป็น nil แปลว่าทำงานสำเร็จ แต่ถ้าไม่ nil แปลว่ามีข้อผิดพลาดเกิดขึ้น

.play methods/errors.go

* แบบฝึกหัด: Errors

สำเนาฟังก์ชั่น `Sqrt` ของคุณจาก [[/flowcontrol/8][แบบฝึกหัดก่อนหน้านี้]] และแก้ไขมันให้คืนค่า `error` ออกมาด้วย

`Sqrt` ควรจะคืนค่า error ที่ไม่เป็น nil ถ้าหากใส่ค่าตัวเลขติดลบลงไป เพราะมันไม่รองรับตัวเลขจำนวนเชิงซ้อน

สร้างชนิดของตัวแปรแบบใหม่

	type ErrNegativeSqrt float64

ทำให้มันเป็น `error` ด้วยการใส่เมธอด

	func (e ErrNegativeSqrt) Error() string

มันจะทำงานแบบนี้ `ErrNegativeSqrt(-2).Error()` และคืนค่านี้ออกมา `"cannot`Sqrt`negative`number:`-2"`

*ข้อสังเกต:* การเรียก `fmt.Sprint(e)` ข้างในเมธอด `Error` จะส่งผลให้เกิด ลูปอนันต์ ดังนั้นคุณควรหลีกเลี่ยงมันด้วยการแปลงค่า `e` เสียก่อน: `fmt.Sprint(float64(e))` อย่าถามนะว่าทำไม?

ทีนี้ลองแก้ฟังก์ชั่น `Sqrt` ของคุณให้มันคืนค่า `ErrNegativeSqrt` ถ้าหากใส่ตัวเลขติดลบลงไป

.play methods/exercise-errors.go

* Readers

ในแพ็กเกจ `io` มี interface ตัวหนึ่งคือ `io.Reader`
มันทำหน้าที่เป็นตัวแทนการ อ่านข้อมูลทั้งหมดออกจากข้อมุลที่ไหลเข้ามา (stream of data)

ในไลบรารี่มาตรฐานของภาษาโก [[https://golang.org/search?q=Read#Global][มีหลายตัวที่อิมพลีเม้นต์]] interface นี้, ได้แก่ พวกที่ทำงานกับไฟล์, การเชื่อมต่อเน็ตเวิร์ค, การบีบอัดข้อมูล, การเข้ารหัส, และอื่น ๆ

interface `io.Reader` มีเมธอดหนึ่งชื่อว่า `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` จะเติมข้อมูลลงไปใน slice ของ byte และจะคืนค่าจำนวนของ byte ที่เติมลงไป
และค่า error โดยมันจะคืน error ค่า `io.EOF` ถ้าหากว่าไม่เหลือข้อมูลให้อ่านแล้ว

โค้ดตัวอย่างนี้จะสร้าง
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
และมันจะดึงข้อมูลออกมาทีละ 8 ไบต์ ในแต่ละครั้ง

.play methods/reader.go

* แบบฝึกหัด: Readers

ให้สร้างชนิดข้อมูลที่ทำงานแบบ `Reader` ที่จะปล่อยตัวอักษร `A` ของรหัส ASCII ออกมาเสมอ

.play methods/exercise-reader.go

* แบบฝึกหัด: rot13Reader

มีท่าที่เจอบ่อย ๆ ก็คือ [[https://golang.org/pkg/io/#Reader][io.Reader]] ถูกห่อด้วย `io.Reader` อีกชั้นหนึ่งเพื่อแก้ไขบางอย่างตอนที่จะดึงข้อมูลออกมา

ตัวอย่างเช่น [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] รับค่า `io.Reader` มาตัวหนึ่ง (เป็นกระแสข้อมูลที่ถูกบีบอัดแล้ว) และคืนค่า `*gzip.Reader` ซึ่งก็เป็น `io.Reader` เหมือนกัน (เป็นกระแสข้อมูลที่คลายการบีบอัดออกมาแล้ว)

จงทำ `rot13Reader` ให้เสร็จ ด้วยการทำให้เป็น `io.Reader` และอ่านค่าจาก `io.Reader` ตัวหนึ่งมาแก้ไขค่าโดยใช้วิธีจาก [[https://en.wikipedia.org/wiki/ROT13][rot13]] ในการเข้ารหัสแทนที่ทุกตัวอักษร

ชนิดตัวแปรแบบ `rot13Reader` มีไว้ให้แล้ว
ทำให้มันทำงานแบบ `io.Reader` โดยสร้างเมธอด `Read`

.play methods/exercise-rot-reader.go

* Images

[[https://golang.org/pkg/image/#Image][ที่แพ็กเกจ image]] มี interface ชื่อ `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*ข้อสังเกต*: ค่า `Rectangle` ที่ถูกคืนออกมาจากเมธอด `Bounds` แท้จริงแล้วก็คือ
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], ที่ประกาศ
อยู่ภายในแพ็กเกจ `image` เช่นเดียวกัน

(ดู [[https://golang.org/pkg/image/#Image][เอกสาร]] หากต้องการข้อมูลทั้งหมด)

ส่วนชนิดตัวแปร `color.Color` และ `color.Model` ก็เป็น interface เหมือนกัน แต่เราจะข้ามมันไปด้วยการไปใช้ `color.RGBA` และ `color.RGBAModel` ซึ่งเป็นตัวที่สร้างรอไว้แล้ว โดย interface เหล่านี้นั้นถูกกำหนดขึ้นโดย [[https://golang.org/pkg/image/color/][image/color package]]

.play methods/images.go

* แบบฝึกหัด: Images

คุณจำโปรแกรมสร้างภาพที่คุณเขียนไว้ก่อนหน้านี้ได้ไหม? ให้เขียนขึ้นมาใหม่อีกครั้งหนึ่ง แต่ครั้งนี้จะให้มันคืนค่าออกมาเป็นอะไรบางอย่างที่ทำงานแบบ `image.Image` แทนที่จะคืนออกมาเป็น slice

จงทำ `Image` ให้ของคุณให้มี [[https://golang.org/pkg/image/#Image][เมธอดที่จำเป็น]] และเรียกใช้ `pic.ShowImage`

`Bounds` ควรคืนค่า `image.Rectangle`, เหมือนกับ `image.Rect(0,`0,`w,`h)`

`ColorModel` ควรคืนค่า `color.RGBAModel`.

`At` ควรคืนค่าสีออกมาสีหนึ่ง โดยค่า `v` ที่ให้ใน `color.RGBA{v,`v,`255,`255}` จะส่งผลกับค่าสีที่ได้

.play methods/exercise-images.go

* ยินดีด้วย!

คุณจบบทนี้แล้ว!

คุณสามารถย้อนกลับไปดูรายการทั้งหมดได้ที่ [[/list][modules]] เพื่อค้นหาสิ่งที่คุณอยากจะเรียนรู้ต่อ หรือไปสู่ [[javascript:click('.next-page')][บทถัดไป]]
