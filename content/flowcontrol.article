รูปแบบของ Flow control: for, if, else, switch และ defer
เรียนรู้การควบคุมการไหลของโค้ดด้วยเงื่อนไข ลูป switch และ defer

The Go Authors
https://golang.org

* For

ภาษาโกมีวิธีวนลูปแบบเดียวคือ `for`

การใช้ `for` แบบพื้นฐานคือใส่ค่าส่วนประกอบสามค่าลงไป แบ่งวรรคแต่ละค่าด้วย เซมิโคลอน:

- ส่วนกำหนดค่าเริ่มต้น: ถูกทำก่อนเริ่มวนรอบแรก
- ส่วนกำหนดเงื่อนไข: จะถูกคำนวณก่อนจะเริ่มทุก ๆ รอบ
- ส่วนที่ทำทีหลัง: จะถูกทำทุกครั้งหลังจบแต่ละรอบ

ขั้นตอนของ ส่วนกำหนดค่าเริ่มต้น ส่วนมากจะเป็นการประกาศตัวแปรแบบย่อ
และตัวแปรที่ถูกประกาศจะใช้ได้แค่ในขอบเขตของ `for` นี้เท่านั้น

ลูปจะหยุดเมื่อค่านิพจน์จาก ส่วนกำหนดเงื่อนไข ถูกคำนวณว่าได้ค่า `false`

_โปรดจำไว้ว่า_: สิ่งที่ต่างจากภาษาอื่น ๆ อย่าง ภาษาซี, จาวา หรือ จาวาสคริป ก็คือมันไม่มีวงเล็บ
ครอบค่าส่วนประกอบสามค่าของ `for` และวงเล็บปีกกา `{`}` จะต้องมีเสมอ

.play flowcontrol/for.go

* For (ต่อ)

ส่วนของการ กำหนดค่าเริ่มต้น และ ส่วนที่ทำทีหลัง นั้นจะมีหรือไม่มีก็ได้

.play flowcontrol/for-continued.go

* For คือ "while" ในภาษาโก

ไม่ยากเลย แค่เอาเซมิโคลอนออกไป หรือจะพูดง่าย ๆ คือ `while` ของภาษาซี สะกดว่า `for` ในภาษาโกก็ได้

.play flowcontrol/for-is-gos-while.go

* ทำซ้ำแบบอนันต์

ถ้าคุณละการกำหนดเงื่อนไข มันจะกลายเป็นทำซ้ำไปเรื่อย ๆ และมันจะเป็นการทำซ้ำแบบไม่มีที่สิ้นสุดที่กระทัดรัดมาก

.play flowcontrol/forever.go

* If

`if` ในภาษาโก ก็คล้ายกับ `for` ลูป ที่ไม่ต้องมีวงเล็บครอบ `(`)` แต่ปีกกาต้องมีเสมอ `{`}`

.play flowcontrol/if.go

* If แบบย่อ

เช่นเดียวกับ `for` การประกาศ `if` สามารถเริ่มด้วยคำสั่งบางอย่างก่อนที่จะถามเงื่อนไข

ตัวแปรที่ประกาศภายในนี้ก็จะใช้ได้ภายในขอบเขตของ `if` นี้เท่านั้น

(ทดลองเอา `v` ไปไว้ในส่วนของ `return` ที่ตอบจบของฟังก์ชั่นแทนดู)

.play flowcontrol/if-with-a-short-statement.go

* If และ else

ตัวแปรที่ประกาศไว้สั้น ๆ ภายใน `if` ยังสามารถใช้ได้ในส่วนของ `else` ทั้งหมดได้ด้วย

(ในฟังก์ชั่น `main` ทั้งสองบรรทัดเรียกใช้ฟังก์ชั่น `pow` และคืนค่ามาก่อนที่จะเรียกฟังก์ชั่น `fmt.Println` ต่อ)

.play flowcontrol/if-and-else.go

* แบบฝึกหัด: ลูป และ ฟังก์ชั่น

ถ้าอยากจะลองที่จะเล่นกับฟังก์ชั่นและลูป มาลองสร้างฟังก์ชั่นหาค่ารากที่สองกัน โดยกำหนดค่า x ที่เป็นตัวเลขให้ และเราต้องการหาค่า z ที่ทำให้ z² มีค่าใกล้ x ที่สุด

ปกติคอมพิวเตอร์จะคำนวณค่ารากที่สองของ x ด้วยการใช้ลูป โดยการเริ่มจากการเดาค่า z มาก่อน และปรับค่า z ไปเรื่อย ๆ โดยดูจากว่าค่า z² นั้นเข้าใกล้ x แค่ไหน เพื่อให้เดาได้ดีขึ้น:

	z -= (z*z - x) / (2*z)

ทำซ้ำการปรับค่า z นี้เพื่อให้ให้การเดาดีขึ้นเรื่อย ๆ จนกว่าเราจะได้คำตอบที่ใกล้เคียงค่ารากที่สองที่แท้จริงที่สุดเท่าที่จะเป็นไปได้

ให้ลองสร้างฟังก์ชั่นนี้ใน `func`Sqrt` ที่เตรียมไว้ให้ ค่า z เริ่มต้นกำหนดให้เป็น 1 โดยไม่ได้สนใจว่าค่าอินพุตจะเป็นอะไร เริ่มต้นโดยลองทำซ้ำการคำนวณ 10 รอบ และลองแสดงค่า z ออกมาดูในทุก ๆ รอบ ลองสังเกตดูว่าเมื่อ x เปลี่ยนไป (1, 2, 3, ...) เราจะได้ค่าที่ใกล้เคียงกับคำตอบจริง ๆ มากขึ้นแค่ไหน และลองดูว่าค่าที่เราเดาในแต่ละรอบมันดีขึ้นเร็วเพียงใด

คำแนะนำ: สร้างตัวแปรและกำหนดค่าเบื้องต้นของเลขทศนิยมด้วยการกำหนดค่าของเลขทศนิยม หรือใช้การแปลงค่าแบบนี้:

	z := 1.0
	z := float64(1)

จากนั้น เปลี่ยนเงื่อนไขในการหยุด ให้หยุดเมื่อค่าที่ได้ไม่มีการเปลี่ยนแปลงอีกต่อไป (หรือเปลี่ยนแปลงน้อยมาก) ให้ดูว่ามันทำซ้ำมากหรือน้อยรอบกว่า 10 รอบ ลองกำหนดค่า z เริ่มต้นเป็นอย่างอื่น เช่น x หรือ x/2 ดูบ้าง ผลลัพธ์ที่ได้ใกล้เคียงกับที่ได้จาก [[https://golang.org/pkg/math/#Sqrt][math.Sqrt]] ในไลบรารี่มาตรฐานหรือไม่?

(*หมายเหตุ:* ถ้าคุณสนใจในรายละเอียดของอัลกอริธึม ค่า z² - x ข้างบนจะเป็นค่าที่ดูว่าค่า z² นั้นห่างจากค่าที่ควรจะเป็น (x) แค่ไหน และการหารด้วย 2z จะเป็นการหาอนุพันธ์ของ z² เพื่อที่จะใช้ในการปรับค่า z โดยดูว่าค่า z² เปลี่ยนแปลงเร็วแค่ไหน) วิธีการนี้เราเรียกว่า [[https://en.wikipedia.org/wiki/Newton%27s_method][วิธีการของนิวตัน]] วิธีการนี้ใช้งานอยู่ในหลาย ๆ ฟังก์ชั่น แต่มันทำงานได้ดีมากในการหาค่ารากที่สอง)

.play flowcontrol/exercise-loops-and-functions.go

* Switch

การใช้ `switch` จะเป็นวิธีการเขียน `if`-`else` หลาย ๆ ทีอย่างสั้น ๆ มันจะทดสอบกับเคสแรกเพื่อดูว่าค่าของมันตรงกับเงื่อนไขหรือไม่

switch ในภาษาโกเหมือนกับในภาษาซี ซีพลัสพลัส จาวา จาวาสคริป และพีเอชพี ยกเว้นแต่ภาษาโกจะรันเฉพาะเคสที่เลือก และจะไม่รันเคสที่อยู่ตามมา
นั่นคือ คำสั่ง `break` ที่จะต้องใส่ตอนท้ายของแต่ละเคสในภาษาอื่น ๆ จะถูกใส่ให้อัตโนมัติในภาษาโก
อีกสิ่งที่แตกต่างอย่างสำคัญคือเคสในภาษาโกไม่จำเป็นต้องเป็นค่าคงที่ และค่าที่ใช้ก็ไม่จำเป็นต้องเป็นตัวเลขจำนวนเต็ม

.play flowcontrol/switch.go

* Switch ทำตามลำดับ

Switch จะประเมินแต่ละเคสจากบนลงล่าง และจะหยุดเมื่อเจอเคสที่ตรง

(ตัวอย่างเช่น,

	switch i {
	case 0:
	case f():
	}

ฟังก์ชั่น `f` จะไม่ถูกเรียกใช้เลย ถ้า `i==0` เป็นจริง)

#appengine: *โปรดจำไว้ว่า:* เวลาใน playground ของภาษาโกจะเริ่มต้นที่
#appengine: 2009-11-10 23:00:00 UTC เสมอ ซึ่งเป็นค่าที่กำหนดไว้สำหรับ
#appengine: ให้ผู้อ่านใช้ทำแบบฝึกหัด

.play flowcontrol/switch-evaluation-order.go

* Switch แบบไม่มีเงื่อนไข

Switch แบบไม่มีเงื่อนไขก็เหมือนกับ `switch`true`

รูปแบบนี้เหมาะจะใช้แทนการมี if-then-else ต่อกันหลาย ๆ ทอด

.play flowcontrol/switch-with-no-condition.go

* Defer

คำสั่ง defer จะหน่วงการเรียกใช้ฟังก์ชั่นที่ระบุไว้ จนกว่าฟังก์ชั่นที่ครอบมันอยู่ทำงานเสร็จสิ้นจนกระทั้งคืนค่าแล้ว

อาร์กิวเมนต์ของฟังก์ชั่นที่ถูกหน่วงไว้ จะถูกประเมินค่าทันที เพียงแต่ตัวฟังก์ชั่นจะยังไม่ถูกเรียกจนกว่าฟังก์ชั่นที่ครอบมันอยู่จะคืนค่าออกไปก่อน

.play flowcontrol/defer.go

* การ defer เป็นชั้น ๆ

ฟังก์ชั่นที่ถูกหน่วงจะถูกใส่ลงไปกองซ้อนกันไว้ก่อนเป็นชั้น ๆ และเมื่อใดที่ฟังก์ชั่นที่ครอบมันอยู่ คืนค่ากลับ
บรรดาฟังก์ชั่นที่ถูกหน่วงไว้จะถูกหยิบมาเรียกทีละตัวแบบ last-in-first-out คือตัวสุดท้ายจะถูกทำก่อนนั่นเอง

หากต้องการรู้เกี่ยวกับ defer เพิ่มเติม ให้อ่านที่นี่
[[https://blog.golang.org/defer-panic-and-recover][blog post]]

.play flowcontrol/defer-multi.go

* ยินดีด้วย!

คุณได้จบบทนี้แล้ว!

คุณสามารถย้อนกลับไปดูรายการทั้งหมดของ [[/list][modules]] เพื่อดูว่าจะเรียนอะไรต่อไป หรือไปต่อที่ [[javascript:click('.next-page')][บทต่อไป]]
